Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _assert = require('assert');

var _assert2 = _interopRequireDefault(_assert);

var _path4 = require('path');

var _path5 = _interopRequireDefault(_path4);

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

// NuclideUri's are either a local file path, or a URI
// of the form nuclide://<host>:<port><path>
//
// This package creates, queries and decomposes NuclideUris.

var REMOTE_PATH_URI_PREFIX = 'nuclide://';

function isRemote(uri) {
  return uri.startsWith(REMOTE_PATH_URI_PREFIX);
}

function isLocal(uri) {
  return !isRemote(uri);
}

function createRemoteUri(hostname, remotePort, remotePath) {
  return 'nuclide://' + hostname + ':' + remotePort + remotePath;
}

/**
 * Parses `uri` with Node's `url.parse` and calls `decodeURI` on `href`, `path`, and `pathname` of
 * the parsed URL object.
 *
 * * `url.parse` seems to apply encodeURI to the URL, and we typically don't want this behavior.
 * * Nuclide URIs disallow use of the `hash` attribute, and any hash characters are interpreted as
 *   as literal hashes.
 *
 *   For example:
 *
 *       parse('nuclide://f.co:123/path/to/#foo.txt#')
 *       >
 *         {
 *           ...
 *           path: '/path/to/#foo.txt#',
 *           ...
 *         }
 */
function parse(uri) {
  var parsedUri = _url2['default'].parse(uri);

  (0, _assert2['default'])(parsedUri.path, 'Nuclide URIs must contain paths, \'' + parsedUri.path + '\' found.');
  var path = parsedUri.path;
  // `url.parse` treates the first '#' character as the beginning of the `hash` attribute. That
  // feature is not used in Nuclide and is instead treated as part of the path.
  if (parsedUri.hash != null) {
    path += parsedUri.hash;
  }

  (0, _assert2['default'])(parsedUri.pathname, 'Nuclide URIs must contain pathnamess, \'' + parsedUri.pathname + '\' found.');
  var pathname = parsedUri.pathname;
  // `url.parse` treates the first '#' character as the beginning of the `hash` attribute. That
  // feature is not used in Nuclide and is instead treated as part of the pathname.
  if (parsedUri.hash != null) {
    pathname += parsedUri.hash;
  }

  // Explicitly copying object properties appeases Flow's "maybe" type handling. Using the `...`
  // operator causes null/undefined errors, and `Object.assign` bypasses type checking.
  return {
    auth: parsedUri.auth,
    host: parsedUri.host,
    hostname: parsedUri.hostname,
    href: decodeURI(parsedUri.href),
    path: decodeURI(path),
    pathname: decodeURI(pathname),
    port: parsedUri.port,
    protocol: parsedUri.protocol,
    query: parsedUri.query,
    search: parsedUri.search,
    slashes: parsedUri.slashes
  };
}

function parseRemoteUri(remoteUri) {
  if (!isRemote(remoteUri)) {
    throw new Error('Expected remote uri. Got ' + remoteUri);
  }
  var parsedUri = parse(remoteUri);
  (0, _assert2['default'])(parsedUri.hostname, 'Remote Nuclide URIs must contain hostnames, \'' + parsedUri.hostname + '\' found.');
  (0, _assert2['default'])(parsedUri.port, 'Remote Nuclide URIs must have port numbers, \'' + parsedUri.port + '\' found.');

  // Explicitly copying object properties appeases Flow's "maybe" type handling. Using the `...`
  // operator causes null/undefined errors, and `Object.assign` bypasses type checking.
  return {
    auth: parsedUri.auth,
    host: parsedUri.host,
    hostname: parsedUri.hostname,
    href: parsedUri.href,
    path: parsedUri.path,
    pathname: parsedUri.pathname,
    port: parsedUri.port,
    protocol: parsedUri.protocol,
    query: parsedUri.query,
    search: parsedUri.search,
    slashes: parsedUri.slashes
  };
}

function getPath(uri) {
  return parse(uri).path;
}

function getHostname(remoteUri) {
  return parseRemoteUri(remoteUri).hostname;
}

function getPort(remoteUri) {
  return Number(parseRemoteUri(remoteUri).port);
}

function join(uri) {
  for (var _len = arguments.length, relativePath = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    relativePath[_key - 1] = arguments[_key];
  }

  if (isRemote(uri)) {
    var _parseRemoteUri = parseRemoteUri(uri);

    var _hostname = _parseRemoteUri.hostname;
    var _port = _parseRemoteUri.port;
    var _path = _parseRemoteUri.path;

    relativePath.splice(0, 0, _path);
    return createRemoteUri(_hostname, Number(_port), _path5['default'].join.apply(null, relativePath));
  } else {
    relativePath.splice(0, 0, uri);
    return _path5['default'].join.apply(null, relativePath);
  }
}

function normalize(uri) {
  if (isRemote(uri)) {
    var _parseRemoteUri2 = parseRemoteUri(uri);

    var _hostname2 = _parseRemoteUri2.hostname;
    var _port2 = _parseRemoteUri2.port;
    var _path2 = _parseRemoteUri2.path;

    return createRemoteUri(_hostname2, Number(_port2), _path5['default'].normalize(_path2));
  } else {
    return _path5['default'].normalize(uri);
  }
}

function getParent(uri) {
  // TODO: Is this different than dirname?
  return normalize(join(uri, '..'));
}

function relative(uri, other) {
  var remote = isRemote(uri);
  if (remote !== isRemote(other) || remote && getHostname(uri) !== getHostname(other)) {
    throw new Error('Cannot relative urls on different hosts.');
  }
  if (remote) {
    return _path5['default'].relative(getPath(uri), getPath(other));
  } else {
    return _path5['default'].relative(uri, other);
  }
}

// TODO: Add optional ext parameter
function basename(uri) {
  if (isRemote(uri)) {
    return _path5['default'].basename(getPath(uri));
  } else {
    return _path5['default'].basename(uri);
  }
}

function dirname(uri) {
  if (isRemote(uri)) {
    var _parseRemoteUri3 = parseRemoteUri(uri);

    var _hostname3 = _parseRemoteUri3.hostname;
    var _port3 = _parseRemoteUri3.port;
    var _path3 = _parseRemoteUri3.path;

    return createRemoteUri(_hostname3, Number(_port3), _path5['default'].dirname(_path3));
  } else {
    return _path5['default'].dirname(uri);
  }
}

/**
 * uri is either a file: uri, or a nuclide: uri.
 * must convert file: uri's to just a path for atom.
 *
 * Returns null if not a valid file: URI.
 */
function uriToNuclideUri(uri) {
  var urlParts = _url2['default'].parse(uri, false);
  if (urlParts.protocol === 'file:' && urlParts.path) {
    // only handle real files for now.
    return urlParts.path;
  } else if (isRemote(uri)) {
    return uri;
  } else {
    return null;
  }
}

/**
 * Converts local paths to file: URI's. Leaves remote URI's alone.
 */
function nuclideUriToUri(uri) {
  if (isRemote(uri)) {
    return uri;
  } else {
    return 'file://' + uri;
  }
}

module.exports = {
  basename: basename,
  dirname: dirname,
  isRemote: isRemote,
  isLocal: isLocal,
  createRemoteUri: createRemoteUri,
  parse: parse,
  parseRemoteUri: parseRemoteUri,
  getPath: getPath,
  getHostname: getHostname,
  getPort: getPort,
  join: join,
  relative: relative,
  normalize: normalize,
  getParent: getParent,
  uriToNuclideUri: uriToNuclideUri,
  nuclideUriToUri: nuclideUriToUri
};
//# sourceMappingURL=data:application/json;base64,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OztBQUVELE1BQU0sQ0FBQyxPQUFPLEdBQUc7QUFDZixVQUFRLEVBQVIsUUFBUTtBQUNSLFNBQU8sRUFBUCxPQUFPO0FBQ1AsVUFBUSxFQUFSLFFBQVE7QUFDUixTQUFPLEVBQVAsT0FBTztBQUNQLGlCQUFlLEVBQWYsZUFBZTtBQUNmLE9BQUssRUFBTCxLQUFLO0FBQ0wsZ0JBQWMsRUFBZCxjQUFjO0FBQ2QsU0FBTyxFQUFQLE9BQU87QUFDUCxhQUFXLEVBQVgsV0FBVztBQUNYLFNBQU8sRUFBUCxPQUFPO0FBQ1AsTUFBSSxFQUFKLElBQUk7QUFDSixVQUFRLEVBQVIsUUFBUTtBQUNSLFdBQVMsRUFBVCxTQUFTO0FBQ1QsV0FBUyxFQUFULFNBQVM7QUFDVCxpQkFBZSxFQUFmLGVBQWU7QUFDZixpQkFBZSxFQUFmLGVBQWU7Q0FDaEIsQ0FBQyIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuLy8gTnVjbGlkZVVyaSdzIGFyZSBlaXRoZXIgYSBsb2NhbCBmaWxlIHBhdGgsIG9yIGEgVVJJXG4vLyBvZiB0aGUgZm9ybSBudWNsaWRlOi8vPGhvc3Q+Ojxwb3J0PjxwYXRoPlxuLy9cbi8vIFRoaXMgcGFja2FnZSBjcmVhdGVzLCBxdWVyaWVzIGFuZCBkZWNvbXBvc2VzIE51Y2xpZGVVcmlzLlxuXG5leHBvcnQgdHlwZSBOdWNsaWRlVXJpID0gc3RyaW5nO1xuXG50eXBlIFBhcnNlZFVybCA9IHtcbiAgYXV0aDogP3N0cmluZztcbiAgaHJlZjogc3RyaW5nO1xuICBob3N0OiA/c3RyaW5nO1xuICBob3N0bmFtZTogP3N0cmluZztcbiAgcGF0aDogc3RyaW5nO1xuICBwYXRobmFtZTogc3RyaW5nO1xuICBwb3J0OiA/c3RyaW5nO1xuICBwcm90b2NvbDogP3N0cmluZztcbiAgcXVlcnk6ID9hbnk7XG4gIHNlYXJjaDogP3N0cmluZztcbiAgc2xhc2hlczogP2Jvb2xlYW47XG59O1xuXG50eXBlIFBhcnNlZFJlbW90ZVVybCA9IHtcbiAgYXV0aDogP3N0cmluZztcbiAgaHJlZjogc3RyaW5nO1xuICBob3N0OiA/c3RyaW5nO1xuICBob3N0bmFtZTogc3RyaW5nO1xuICBwYXRoOiBzdHJpbmc7XG4gIHBhdGhuYW1lOiBzdHJpbmc7XG4gIHBvcnQ6IHN0cmluZztcbiAgcHJvdG9jb2w6ID9zdHJpbmc7XG4gIHF1ZXJ5OiA/YW55O1xuICBzZWFyY2g6ID9zdHJpbmc7XG4gIHNsYXNoZXM6ID9ib29sZWFuO1xufTtcblxuaW1wb3J0IGludmFyaWFudCBmcm9tICdhc3NlcnQnO1xuaW1wb3J0IHBhdGhNb2R1bGUgZnJvbSAncGF0aCc7XG5pbXBvcnQgdXJsIGZyb20gJ3VybCc7XG5cbmNvbnN0IFJFTU9URV9QQVRIX1VSSV9QUkVGSVggPSAnbnVjbGlkZTovLyc7XG5cbmZ1bmN0aW9uIGlzUmVtb3RlKHVyaTogTnVjbGlkZVVyaSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdXJpLnN0YXJ0c1dpdGgoUkVNT1RFX1BBVEhfVVJJX1BSRUZJWCk7XG59XG5cbmZ1bmN0aW9uIGlzTG9jYWwodXJpOiBOdWNsaWRlVXJpKTogYm9vbGVhbiB7XG4gIHJldHVybiAhaXNSZW1vdGUodXJpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVtb3RlVXJpKGhvc3RuYW1lOiBzdHJpbmcsIHJlbW90ZVBvcnQ6IG51bWJlciwgcmVtb3RlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGBudWNsaWRlOi8vJHtob3N0bmFtZX06JHtyZW1vdGVQb3J0fSR7cmVtb3RlUGF0aH1gO1xufVxuXG4vKipcbiAqIFBhcnNlcyBgdXJpYCB3aXRoIE5vZGUncyBgdXJsLnBhcnNlYCBhbmQgY2FsbHMgYGRlY29kZVVSSWAgb24gYGhyZWZgLCBgcGF0aGAsIGFuZCBgcGF0aG5hbWVgIG9mXG4gKiB0aGUgcGFyc2VkIFVSTCBvYmplY3QuXG4gKlxuICogKiBgdXJsLnBhcnNlYCBzZWVtcyB0byBhcHBseSBlbmNvZGVVUkkgdG8gdGhlIFVSTCwgYW5kIHdlIHR5cGljYWxseSBkb24ndCB3YW50IHRoaXMgYmVoYXZpb3IuXG4gKiAqIE51Y2xpZGUgVVJJcyBkaXNhbGxvdyB1c2Ugb2YgdGhlIGBoYXNoYCBhdHRyaWJ1dGUsIGFuZCBhbnkgaGFzaCBjaGFyYWN0ZXJzIGFyZSBpbnRlcnByZXRlZCBhc1xuICogICBhcyBsaXRlcmFsIGhhc2hlcy5cbiAqXG4gKiAgIEZvciBleGFtcGxlOlxuICpcbiAqICAgICAgIHBhcnNlKCdudWNsaWRlOi8vZi5jbzoxMjMvcGF0aC90by8jZm9vLnR4dCMnKVxuICogICAgICAgPlxuICogICAgICAgICB7XG4gKiAgICAgICAgICAgLi4uXG4gKiAgICAgICAgICAgcGF0aDogJy9wYXRoL3RvLyNmb28udHh0IycsXG4gKiAgICAgICAgICAgLi4uXG4gKiAgICAgICAgIH1cbiAqL1xuZnVuY3Rpb24gcGFyc2UodXJpOiBOdWNsaWRlVXJpKTogUGFyc2VkVXJsIHtcbiAgY29uc3QgcGFyc2VkVXJpID0gdXJsLnBhcnNlKHVyaSk7XG5cbiAgaW52YXJpYW50KHBhcnNlZFVyaS5wYXRoLCBgTnVjbGlkZSBVUklzIG11c3QgY29udGFpbiBwYXRocywgJyR7cGFyc2VkVXJpLnBhdGh9JyBmb3VuZC5gKTtcbiAgbGV0IHBhdGggPSBwYXJzZWRVcmkucGF0aDtcbiAgLy8gYHVybC5wYXJzZWAgdHJlYXRlcyB0aGUgZmlyc3QgJyMnIGNoYXJhY3RlciBhcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBgaGFzaGAgYXR0cmlidXRlLiBUaGF0XG4gIC8vIGZlYXR1cmUgaXMgbm90IHVzZWQgaW4gTnVjbGlkZSBhbmQgaXMgaW5zdGVhZCB0cmVhdGVkIGFzIHBhcnQgb2YgdGhlIHBhdGguXG4gIGlmIChwYXJzZWRVcmkuaGFzaCAhPSBudWxsKSB7XG4gICAgcGF0aCArPSBwYXJzZWRVcmkuaGFzaDtcbiAgfVxuXG4gIGludmFyaWFudChcbiAgICBwYXJzZWRVcmkucGF0aG5hbWUsXG4gICAgYE51Y2xpZGUgVVJJcyBtdXN0IGNvbnRhaW4gcGF0aG5hbWVzcywgJyR7cGFyc2VkVXJpLnBhdGhuYW1lfScgZm91bmQuYFxuICApO1xuICBsZXQgcGF0aG5hbWUgPSBwYXJzZWRVcmkucGF0aG5hbWU7XG4gIC8vIGB1cmwucGFyc2VgIHRyZWF0ZXMgdGhlIGZpcnN0ICcjJyBjaGFyYWN0ZXIgYXMgdGhlIGJlZ2lubmluZyBvZiB0aGUgYGhhc2hgIGF0dHJpYnV0ZS4gVGhhdFxuICAvLyBmZWF0dXJlIGlzIG5vdCB1c2VkIGluIE51Y2xpZGUgYW5kIGlzIGluc3RlYWQgdHJlYXRlZCBhcyBwYXJ0IG9mIHRoZSBwYXRobmFtZS5cbiAgaWYgKHBhcnNlZFVyaS5oYXNoICE9IG51bGwpIHtcbiAgICBwYXRobmFtZSArPSBwYXJzZWRVcmkuaGFzaDtcbiAgfVxuXG4gIC8vIEV4cGxpY2l0bHkgY29weWluZyBvYmplY3QgcHJvcGVydGllcyBhcHBlYXNlcyBGbG93J3MgXCJtYXliZVwiIHR5cGUgaGFuZGxpbmcuIFVzaW5nIHRoZSBgLi4uYFxuICAvLyBvcGVyYXRvciBjYXVzZXMgbnVsbC91bmRlZmluZWQgZXJyb3JzLCBhbmQgYE9iamVjdC5hc3NpZ25gIGJ5cGFzc2VzIHR5cGUgY2hlY2tpbmcuXG4gIHJldHVybiB7XG4gICAgYXV0aDogcGFyc2VkVXJpLmF1dGgsXG4gICAgaG9zdDogcGFyc2VkVXJpLmhvc3QsXG4gICAgaG9zdG5hbWU6IHBhcnNlZFVyaS5ob3N0bmFtZSxcbiAgICBocmVmOiBkZWNvZGVVUkkocGFyc2VkVXJpLmhyZWYpLFxuICAgIHBhdGg6IGRlY29kZVVSSShwYXRoKSxcbiAgICBwYXRobmFtZTogZGVjb2RlVVJJKHBhdGhuYW1lKSxcbiAgICBwb3J0OiBwYXJzZWRVcmkucG9ydCxcbiAgICBwcm90b2NvbDogcGFyc2VkVXJpLnByb3RvY29sLFxuICAgIHF1ZXJ5OiBwYXJzZWRVcmkucXVlcnksXG4gICAgc2VhcmNoOiBwYXJzZWRVcmkuc2VhcmNoLFxuICAgIHNsYXNoZXM6IHBhcnNlZFVyaS5zbGFzaGVzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlbW90ZVVyaShyZW1vdGVVcmk6IE51Y2xpZGVVcmkpOiBQYXJzZWRSZW1vdGVVcmwge1xuICBpZiAoIWlzUmVtb3RlKHJlbW90ZVVyaSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlbW90ZSB1cmkuIEdvdCAnICsgcmVtb3RlVXJpKTtcbiAgfVxuICBjb25zdCBwYXJzZWRVcmkgPSBwYXJzZShyZW1vdGVVcmkpO1xuICBpbnZhcmlhbnQoXG4gICAgcGFyc2VkVXJpLmhvc3RuYW1lLFxuICAgIGBSZW1vdGUgTnVjbGlkZSBVUklzIG11c3QgY29udGFpbiBob3N0bmFtZXMsICcke3BhcnNlZFVyaS5ob3N0bmFtZX0nIGZvdW5kLmBcbiAgKTtcbiAgaW52YXJpYW50KFxuICAgIHBhcnNlZFVyaS5wb3J0LFxuICAgIGBSZW1vdGUgTnVjbGlkZSBVUklzIG11c3QgaGF2ZSBwb3J0IG51bWJlcnMsICcke3BhcnNlZFVyaS5wb3J0fScgZm91bmQuYFxuICApO1xuXG4gIC8vIEV4cGxpY2l0bHkgY29weWluZyBvYmplY3QgcHJvcGVydGllcyBhcHBlYXNlcyBGbG93J3MgXCJtYXliZVwiIHR5cGUgaGFuZGxpbmcuIFVzaW5nIHRoZSBgLi4uYFxuICAvLyBvcGVyYXRvciBjYXVzZXMgbnVsbC91bmRlZmluZWQgZXJyb3JzLCBhbmQgYE9iamVjdC5hc3NpZ25gIGJ5cGFzc2VzIHR5cGUgY2hlY2tpbmcuXG4gIHJldHVybiB7XG4gICAgYXV0aDogcGFyc2VkVXJpLmF1dGgsXG4gICAgaG9zdDogcGFyc2VkVXJpLmhvc3QsXG4gICAgaG9zdG5hbWU6IHBhcnNlZFVyaS5ob3N0bmFtZSxcbiAgICBocmVmOiBwYXJzZWRVcmkuaHJlZixcbiAgICBwYXRoOiBwYXJzZWRVcmkucGF0aCxcbiAgICBwYXRobmFtZTogcGFyc2VkVXJpLnBhdGhuYW1lLFxuICAgIHBvcnQ6IHBhcnNlZFVyaS5wb3J0LFxuICAgIHByb3RvY29sOiBwYXJzZWRVcmkucHJvdG9jb2wsXG4gICAgcXVlcnk6IHBhcnNlZFVyaS5xdWVyeSxcbiAgICBzZWFyY2g6IHBhcnNlZFVyaS5zZWFyY2gsXG4gICAgc2xhc2hlczogcGFyc2VkVXJpLnNsYXNoZXMsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhdGgodXJpOiBOdWNsaWRlVXJpKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhcnNlKHVyaSkucGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdG5hbWUocmVtb3RlVXJpOiBOdWNsaWRlVXJpKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhcnNlUmVtb3RlVXJpKHJlbW90ZVVyaSkuaG9zdG5hbWU7XG59XG5cbmZ1bmN0aW9uIGdldFBvcnQocmVtb3RlVXJpOiBOdWNsaWRlVXJpKTogbnVtYmVyIHtcbiAgcmV0dXJuIE51bWJlcihwYXJzZVJlbW90ZVVyaShyZW1vdGVVcmkpLnBvcnQpO1xufVxuXG5mdW5jdGlvbiBqb2luKHVyaTogTnVjbGlkZVVyaSwgLi4ucmVsYXRpdmVQYXRoOiBBcnJheTxzdHJpbmc+KTogTnVjbGlkZVVyaSB7XG4gIGlmIChpc1JlbW90ZSh1cmkpKSB7XG4gICAgY29uc3Qge2hvc3RuYW1lLCBwb3J0LCBwYXRofSA9IHBhcnNlUmVtb3RlVXJpKHVyaSk7XG4gICAgcmVsYXRpdmVQYXRoLnNwbGljZSgwLCAwLCBwYXRoKTtcbiAgICByZXR1cm4gY3JlYXRlUmVtb3RlVXJpKFxuICAgICAgaG9zdG5hbWUsXG4gICAgICBOdW1iZXIocG9ydCksXG4gICAgICBwYXRoTW9kdWxlLmpvaW4uYXBwbHkobnVsbCwgcmVsYXRpdmVQYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmVsYXRpdmVQYXRoLnNwbGljZSgwLCAwLCB1cmkpO1xuICAgIHJldHVybiBwYXRoTW9kdWxlLmpvaW4uYXBwbHkobnVsbCwgcmVsYXRpdmVQYXRoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemUodXJpOiBOdWNsaWRlVXJpKTogTnVjbGlkZVVyaSB7XG4gIGlmIChpc1JlbW90ZSh1cmkpKSB7XG4gICAgY29uc3Qge2hvc3RuYW1lLCBwb3J0LCBwYXRofSA9IHBhcnNlUmVtb3RlVXJpKHVyaSk7XG4gICAgcmV0dXJuIGNyZWF0ZVJlbW90ZVVyaShcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgTnVtYmVyKHBvcnQpLFxuICAgICAgcGF0aE1vZHVsZS5ub3JtYWxpemUocGF0aClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXRoTW9kdWxlLm5vcm1hbGl6ZSh1cmkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudCh1cmk6IE51Y2xpZGVVcmkpOiBOdWNsaWRlVXJpIHtcbiAgLy8gVE9ETzogSXMgdGhpcyBkaWZmZXJlbnQgdGhhbiBkaXJuYW1lP1xuICByZXR1cm4gbm9ybWFsaXplKGpvaW4odXJpLCAnLi4nKSk7XG59XG5cbmZ1bmN0aW9uIHJlbGF0aXZlKHVyaTogTnVjbGlkZVVyaSwgb3RoZXI6IE51Y2xpZGVVcmkpOiBzdHJpbmcge1xuICBjb25zdCByZW1vdGUgPSBpc1JlbW90ZSh1cmkpO1xuICBpZiAocmVtb3RlICE9PSBpc1JlbW90ZShvdGhlcikgfHxcbiAgICAgIChyZW1vdGUgJiYgZ2V0SG9zdG5hbWUodXJpKSAhPT0gZ2V0SG9zdG5hbWUob3RoZXIpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlbGF0aXZlIHVybHMgb24gZGlmZmVyZW50IGhvc3RzLicpO1xuICB9XG4gIGlmIChyZW1vdGUpIHtcbiAgICByZXR1cm4gcGF0aE1vZHVsZS5yZWxhdGl2ZShnZXRQYXRoKHVyaSksIGdldFBhdGgob3RoZXIpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aE1vZHVsZS5yZWxhdGl2ZSh1cmksIG90aGVyKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBBZGQgb3B0aW9uYWwgZXh0IHBhcmFtZXRlclxuZnVuY3Rpb24gYmFzZW5hbWUodXJpOiBOdWNsaWRlVXJpKTogTnVjbGlkZVVyaSB7XG4gIGlmIChpc1JlbW90ZSh1cmkpKSB7XG4gICAgcmV0dXJuIHBhdGhNb2R1bGUuYmFzZW5hbWUoZ2V0UGF0aCh1cmkpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aE1vZHVsZS5iYXNlbmFtZSh1cmkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpcm5hbWUodXJpOiBOdWNsaWRlVXJpKTogTnVjbGlkZVVyaSB7XG4gIGlmIChpc1JlbW90ZSh1cmkpKSB7XG4gICAgY29uc3Qge2hvc3RuYW1lLCBwb3J0LCBwYXRofSA9IHBhcnNlUmVtb3RlVXJpKHVyaSk7XG4gICAgcmV0dXJuIGNyZWF0ZVJlbW90ZVVyaShcbiAgICAgIGhvc3RuYW1lLFxuICAgICAgTnVtYmVyKHBvcnQpLFxuICAgICAgcGF0aE1vZHVsZS5kaXJuYW1lKHBhdGgpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aE1vZHVsZS5kaXJuYW1lKHVyaSk7XG4gIH1cbn1cblxuLyoqXG4gKiB1cmkgaXMgZWl0aGVyIGEgZmlsZTogdXJpLCBvciBhIG51Y2xpZGU6IHVyaS5cbiAqIG11c3QgY29udmVydCBmaWxlOiB1cmkncyB0byBqdXN0IGEgcGF0aCBmb3IgYXRvbS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgbm90IGEgdmFsaWQgZmlsZTogVVJJLlxuICovXG5mdW5jdGlvbiB1cmlUb051Y2xpZGVVcmkodXJpOiBzdHJpbmcpOiA/c3RyaW5nIHtcbiAgY29uc3QgdXJsUGFydHMgPSB1cmwucGFyc2UodXJpLCBmYWxzZSk7XG4gIGlmICh1cmxQYXJ0cy5wcm90b2NvbCA9PT0gJ2ZpbGU6JyAmJiB1cmxQYXJ0cy5wYXRoKSB7IC8vIG9ubHkgaGFuZGxlIHJlYWwgZmlsZXMgZm9yIG5vdy5cbiAgICByZXR1cm4gdXJsUGFydHMucGF0aDtcbiAgfSBlbHNlIGlmIChpc1JlbW90ZSh1cmkpKSB7XG4gICAgcmV0dXJuIHVyaTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGxvY2FsIHBhdGhzIHRvIGZpbGU6IFVSSSdzLiBMZWF2ZXMgcmVtb3RlIFVSSSdzIGFsb25lLlxuICovXG5mdW5jdGlvbiBudWNsaWRlVXJpVG9VcmkodXJpOiBOdWNsaWRlVXJpKTogc3RyaW5nIHtcbiAgaWYgKGlzUmVtb3RlKHVyaSkpIHtcbiAgICByZXR1cm4gdXJpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnZmlsZTovLycgKyB1cmk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGJhc2VuYW1lLFxuICBkaXJuYW1lLFxuICBpc1JlbW90ZSxcbiAgaXNMb2NhbCxcbiAgY3JlYXRlUmVtb3RlVXJpLFxuICBwYXJzZSxcbiAgcGFyc2VSZW1vdGVVcmksXG4gIGdldFBhdGgsXG4gIGdldEhvc3RuYW1lLFxuICBnZXRQb3J0LFxuICBqb2luLFxuICByZWxhdGl2ZSxcbiAgbm9ybWFsaXplLFxuICBnZXRQYXJlbnQsXG4gIHVyaVRvTnVjbGlkZVVyaSxcbiAgbnVjbGlkZVVyaVRvVXJpLFxufTtcbiJdfQ==