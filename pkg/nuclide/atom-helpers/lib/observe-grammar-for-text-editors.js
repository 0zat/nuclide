var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

/*
 * Copyright (c) 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the license found in the LICENSE file in
 * the root directory of this source tree.
 */

var _require = require('atom');

var Disposable = _require.Disposable;

var _require2 = require('events');

var EventEmitter = _require2.EventEmitter;

var GRAMMAR_CHANGE_EVENT = 'grammar-change';

/**
 * A singleton that listens to grammar changes in all text editors.
 */

var GrammarForTextEditorsListener = (function () {
  function GrammarForTextEditorsListener() {
    var _this = this;

    _classCallCheck(this, GrammarForTextEditorsListener);

    this._emitter = new EventEmitter();
    this._grammarSubscriptionsMap = new Map();
    this._destroySubscriptionsMap = new Map();
    this._textEditorsSubscription = atom.workspace.observeTextEditors(function (textEditor) {
      var grammarSubscription = textEditor.observeGrammar(function (grammar) {
        _this._emitter.emit(GRAMMAR_CHANGE_EVENT, textEditor);
      });
      _this._grammarSubscriptionsMap.set(textEditor, grammarSubscription);

      var destroySubscription = textEditor.onDidDestroy(function () {
        var subscription = _this._grammarSubscriptionsMap.get(textEditor);
        if (subscription) {
          subscription.dispose();
          _this._grammarSubscriptionsMap['delete'](textEditor);
        }

        destroySubscription.dispose();
        _this._destroySubscriptionsMap['delete'](textEditor);
      });
      _this._destroySubscriptionsMap.set(textEditor, destroySubscription);
    });
  }

  _createClass(GrammarForTextEditorsListener, [{
    key: 'observeGrammarForTextEditors',
    value: function observeGrammarForTextEditors(fn) {
      var _this2 = this;

      function fnWithGrammar(textEditor) {
        fn(textEditor, textEditor.getGrammar());
      }

      // The event was already handled before `fn` was added to the emitter, so
      // we need to call it on all the existing editors.
      atom.workspace.getTextEditors().forEach(fnWithGrammar);
      this._emitter.addListener(GRAMMAR_CHANGE_EVENT, fnWithGrammar);
      return new Disposable(function () {
        _this2._emitter.removeListener(GRAMMAR_CHANGE_EVENT, fnWithGrammar);
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._emitter.removeAllListeners();
      this._grammarSubscriptionsMap.forEach(function (subscription) {
        return subscription.dispose();
      });
      this._grammarSubscriptionsMap.clear();
      this._destroySubscriptionsMap.forEach(function (subscription) {
        return subscription.dispose();
      });
      this._destroySubscriptionsMap.clear();
      this._textEditorsSubscription.dispose();
    }
  }]);

  return GrammarForTextEditorsListener;
})();

var grammarForTextEditorsListener = undefined;

/**
 * Use this to perform an action on every text editor with its latest grammar.
 *
 * @param fn This is called once for every text editor, and then again every
 * time it changes to a grammar.
 */
function observeGrammarForTextEditors(fn) {
  if (!grammarForTextEditorsListener) {
    grammarForTextEditorsListener = new GrammarForTextEditorsListener();
  }
  return grammarForTextEditorsListener.observeGrammarForTextEditors(fn);
}

if (atom.inSpecMode()) {
  observeGrammarForTextEditors.__reset__ = function () {
    if (grammarForTextEditorsListener) {
      grammarForTextEditorsListener.dispose();
      grammarForTextEditorsListener = null;
    }
  };
}

module.exports = observeGrammarForTextEditors;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm9ic2VydmUtZ3JhbW1hci1mb3ItdGV4dC1lZGl0b3JzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztlQVdxQixPQUFPLENBQUMsTUFBTSxDQUFDOztJQUE3QixVQUFVLFlBQVYsVUFBVTs7Z0JBQ00sT0FBTyxDQUFDLFFBQVEsQ0FBQzs7SUFBakMsWUFBWSxhQUFaLFlBQVk7O0FBRW5CLElBQU0sb0JBQW9CLEdBQUcsZ0JBQWdCLENBQUM7Ozs7OztJQUt4Qyw2QkFBNkI7QUFNdEIsV0FOUCw2QkFBNkIsR0FNbkI7OzswQkFOViw2QkFBNkI7O0FBTy9CLFFBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztBQUNuQyxRQUFJLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUMxQyxRQUFJLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztBQUMxQyxRQUFJLENBQUMsd0JBQXdCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxVQUFBLFVBQVUsRUFBSTtBQUM5RSxVQUFNLG1CQUFtQixHQUFHLFVBQVUsQ0FBQyxjQUFjLENBQUMsVUFBQSxPQUFPLEVBQUk7QUFDL0QsY0FBSyxRQUFRLENBQUMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLFVBQVUsQ0FBQyxDQUFDO09BQ3RELENBQUMsQ0FBQztBQUNILFlBQUssd0JBQXdCLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDOztBQUVuRSxVQUFNLG1CQUFtQixHQUFHLFVBQVUsQ0FBQyxZQUFZLENBQUMsWUFBTTtBQUN4RCxZQUFNLFlBQVksR0FBRyxNQUFLLHdCQUF3QixDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNuRSxZQUFJLFlBQVksRUFBRTtBQUNoQixzQkFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ3ZCLGdCQUFLLHdCQUF3QixVQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDbEQ7O0FBRUQsMkJBQW1CLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDOUIsY0FBSyx3QkFBd0IsVUFBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO09BQ2xELENBQUMsQ0FBQztBQUNILFlBQUssd0JBQXdCLENBQUMsR0FBRyxDQUFDLFVBQVUsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0tBQ3BFLENBQUMsQ0FBQztHQUNKOztlQTVCRyw2QkFBNkI7O1dBOEJMLHNDQUMxQixFQUEyRCxFQUMvQzs7O0FBQ1osZUFBUyxhQUFhLENBQUMsVUFBVSxFQUFFO0FBQ2pDLFVBQUUsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUM7T0FDekM7Ozs7QUFJRCxVQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN2RCxVQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsRUFBRSxhQUFhLENBQUMsQ0FBQztBQUMvRCxhQUFPLElBQUksVUFBVSxDQUFDLFlBQU07QUFDMUIsZUFBSyxRQUFRLENBQUMsY0FBYyxDQUFDLG9CQUFvQixFQUFFLGFBQWEsQ0FBQyxDQUFDO09BQ25FLENBQUMsQ0FBQztLQUNKOzs7V0FFTSxtQkFBUztBQUNkLFVBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztBQUNuQyxVQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxDQUFDLFVBQUEsWUFBWTtlQUFJLFlBQVksQ0FBQyxPQUFPLEVBQUU7T0FBQSxDQUFDLENBQUM7QUFDOUUsVUFBSSxDQUFDLHdCQUF3QixDQUFDLEtBQUssRUFBRSxDQUFDO0FBQ3RDLFVBQUksQ0FBQyx3QkFBd0IsQ0FBQyxPQUFPLENBQUMsVUFBQSxZQUFZO2VBQUksWUFBWSxDQUFDLE9BQU8sRUFBRTtPQUFBLENBQUMsQ0FBQztBQUM5RSxVQUFJLENBQUMsd0JBQXdCLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDdEMsVUFBSSxDQUFDLHdCQUF3QixDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQ3pDOzs7U0FyREcsNkJBQTZCOzs7QUF3RG5DLElBQUksNkJBQTZELFlBQUEsQ0FBQzs7Ozs7Ozs7QUFRbEUsU0FBUyw0QkFBNEIsQ0FDbkMsRUFBMkQsRUFDOUM7QUFDYixNQUFJLENBQUMsNkJBQTZCLEVBQUU7QUFDbEMsaUNBQTZCLEdBQUcsSUFBSSw2QkFBNkIsRUFBRSxDQUFDO0dBQ3JFO0FBQ0QsU0FBTyw2QkFBNkIsQ0FBQyw0QkFBNEIsQ0FBQyxFQUFFLENBQUMsQ0FBQztDQUN2RTs7QUFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRTtBQUNyQiw4QkFBNEIsQ0FBQyxTQUFTLEdBQUcsWUFBVztBQUNsRCxRQUFJLDZCQUE2QixFQUFFO0FBQ2pDLG1DQUE2QixDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ3hDLG1DQUE2QixHQUFHLElBQUksQ0FBQztLQUN0QztHQUNGLENBQUM7Q0FDSDs7QUFFRCxNQUFNLENBQUMsT0FBTyxHQUFHLDRCQUE0QixDQUFDIiwiZmlsZSI6Im9ic2VydmUtZ3JhbW1hci1mb3ItdGV4dC1lZGl0b3JzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBiYWJlbCc7XG4vKiBAZmxvdyAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIGxpY2Vuc2UgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpblxuICogdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuY29uc3Qge0Rpc3Bvc2FibGV9ID0gcmVxdWlyZSgnYXRvbScpO1xuY29uc3Qge0V2ZW50RW1pdHRlcn0gPSByZXF1aXJlKCdldmVudHMnKTtcblxuY29uc3QgR1JBTU1BUl9DSEFOR0VfRVZFTlQgPSAnZ3JhbW1hci1jaGFuZ2UnO1xuXG4vKipcbiAqIEEgc2luZ2xldG9uIHRoYXQgbGlzdGVucyB0byBncmFtbWFyIGNoYW5nZXMgaW4gYWxsIHRleHQgZWRpdG9ycy5cbiAqL1xuY2xhc3MgR3JhbW1hckZvclRleHRFZGl0b3JzTGlzdGVuZXIge1xuICBfZW1pdHRlcjogRXZlbnRFbWl0dGVyO1xuICBfZ3JhbW1hclN1YnNjcmlwdGlvbnNNYXA6IE1hcDxUZXh0RWRpdG9yLCBJRGlzcG9zYWJsZT47XG4gIF9kZXN0cm95U3Vic2NyaXB0aW9uc01hcDogTWFwPFRleHRFZGl0b3IsIElEaXNwb3NhYmxlPjtcbiAgX3RleHRFZGl0b3JzU3Vic2NyaXB0aW9uOiBJRGlzcG9zYWJsZTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIHRoaXMuX2dyYW1tYXJTdWJzY3JpcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2Rlc3Ryb3lTdWJzY3JpcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3RleHRFZGl0b3JzU3Vic2NyaXB0aW9uID0gYXRvbS53b3Jrc3BhY2Uub2JzZXJ2ZVRleHRFZGl0b3JzKHRleHRFZGl0b3IgPT4ge1xuICAgICAgY29uc3QgZ3JhbW1hclN1YnNjcmlwdGlvbiA9IHRleHRFZGl0b3Iub2JzZXJ2ZUdyYW1tYXIoZ3JhbW1hciA9PiB7XG4gICAgICAgIHRoaXMuX2VtaXR0ZXIuZW1pdChHUkFNTUFSX0NIQU5HRV9FVkVOVCwgdGV4dEVkaXRvcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2dyYW1tYXJTdWJzY3JpcHRpb25zTWFwLnNldCh0ZXh0RWRpdG9yLCBncmFtbWFyU3Vic2NyaXB0aW9uKTtcblxuICAgICAgY29uc3QgZGVzdHJveVN1YnNjcmlwdGlvbiA9IHRleHRFZGl0b3Iub25EaWREZXN0cm95KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdGhpcy5fZ3JhbW1hclN1YnNjcmlwdGlvbnNNYXAuZ2V0KHRleHRFZGl0b3IpO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgICB0aGlzLl9ncmFtbWFyU3Vic2NyaXB0aW9uc01hcC5kZWxldGUodGV4dEVkaXRvcik7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0cm95U3Vic2NyaXB0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveVN1YnNjcmlwdGlvbnNNYXAuZGVsZXRlKHRleHRFZGl0b3IpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9kZXN0cm95U3Vic2NyaXB0aW9uc01hcC5zZXQodGV4dEVkaXRvciwgZGVzdHJveVN1YnNjcmlwdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICBvYnNlcnZlR3JhbW1hckZvclRleHRFZGl0b3JzKFxuICAgIGZuOiAodGV4dEVkaXRvcjogVGV4dEVkaXRvciwgZ3JhbW1hcjogYXRvbSRHcmFtbWFyKSA9PiB2b2lkLFxuICApOiBEaXNwb3NhYmxlIHtcbiAgICBmdW5jdGlvbiBmbldpdGhHcmFtbWFyKHRleHRFZGl0b3IpIHtcbiAgICAgIGZuKHRleHRFZGl0b3IsIHRleHRFZGl0b3IuZ2V0R3JhbW1hcigpKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXZlbnQgd2FzIGFscmVhZHkgaGFuZGxlZCBiZWZvcmUgYGZuYCB3YXMgYWRkZWQgdG8gdGhlIGVtaXR0ZXIsIHNvXG4gICAgLy8gd2UgbmVlZCB0byBjYWxsIGl0IG9uIGFsbCB0aGUgZXhpc3RpbmcgZWRpdG9ycy5cbiAgICBhdG9tLndvcmtzcGFjZS5nZXRUZXh0RWRpdG9ycygpLmZvckVhY2goZm5XaXRoR3JhbW1hcik7XG4gICAgdGhpcy5fZW1pdHRlci5hZGRMaXN0ZW5lcihHUkFNTUFSX0NIQU5HRV9FVkVOVCwgZm5XaXRoR3JhbW1hcik7XG4gICAgcmV0dXJuIG5ldyBEaXNwb3NhYmxlKCgpID0+IHtcbiAgICAgIHRoaXMuX2VtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoR1JBTU1BUl9DSEFOR0VfRVZFTlQsIGZuV2l0aEdyYW1tYXIpO1xuICAgIH0pO1xuICB9XG5cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9lbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX2dyYW1tYXJTdWJzY3JpcHRpb25zTWFwLmZvckVhY2goc3Vic2NyaXB0aW9uID0+IHN1YnNjcmlwdGlvbi5kaXNwb3NlKCkpO1xuICAgIHRoaXMuX2dyYW1tYXJTdWJzY3JpcHRpb25zTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5fZGVzdHJveVN1YnNjcmlwdGlvbnNNYXAuZm9yRWFjaChzdWJzY3JpcHRpb24gPT4gc3Vic2NyaXB0aW9uLmRpc3Bvc2UoKSk7XG4gICAgdGhpcy5fZGVzdHJveVN1YnNjcmlwdGlvbnNNYXAuY2xlYXIoKTtcbiAgICB0aGlzLl90ZXh0RWRpdG9yc1N1YnNjcmlwdGlvbi5kaXNwb3NlKCk7XG4gIH1cbn1cblxubGV0IGdyYW1tYXJGb3JUZXh0RWRpdG9yc0xpc3RlbmVyOiA/R3JhbW1hckZvclRleHRFZGl0b3JzTGlzdGVuZXI7XG5cbi8qKlxuICogVXNlIHRoaXMgdG8gcGVyZm9ybSBhbiBhY3Rpb24gb24gZXZlcnkgdGV4dCBlZGl0b3Igd2l0aCBpdHMgbGF0ZXN0IGdyYW1tYXIuXG4gKlxuICogQHBhcmFtIGZuIFRoaXMgaXMgY2FsbGVkIG9uY2UgZm9yIGV2ZXJ5IHRleHQgZWRpdG9yLCBhbmQgdGhlbiBhZ2FpbiBldmVyeVxuICogdGltZSBpdCBjaGFuZ2VzIHRvIGEgZ3JhbW1hci5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZUdyYW1tYXJGb3JUZXh0RWRpdG9ycyhcbiAgZm46ICh0ZXh0RWRpdG9yOiBUZXh0RWRpdG9yLCBncmFtbWFyOiBhdG9tJEdyYW1tYXIpID0+IHZvaWQsXG4pOiBJRGlzcG9zYWJsZSB7XG4gIGlmICghZ3JhbW1hckZvclRleHRFZGl0b3JzTGlzdGVuZXIpIHtcbiAgICBncmFtbWFyRm9yVGV4dEVkaXRvcnNMaXN0ZW5lciA9IG5ldyBHcmFtbWFyRm9yVGV4dEVkaXRvcnNMaXN0ZW5lcigpO1xuICB9XG4gIHJldHVybiBncmFtbWFyRm9yVGV4dEVkaXRvcnNMaXN0ZW5lci5vYnNlcnZlR3JhbW1hckZvclRleHRFZGl0b3JzKGZuKTtcbn1cblxuaWYgKGF0b20uaW5TcGVjTW9kZSgpKSB7XG4gIG9ic2VydmVHcmFtbWFyRm9yVGV4dEVkaXRvcnMuX19yZXNldF9fID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGdyYW1tYXJGb3JUZXh0RWRpdG9yc0xpc3RlbmVyKSB7XG4gICAgICBncmFtbWFyRm9yVGV4dEVkaXRvcnNMaXN0ZW5lci5kaXNwb3NlKCk7XG4gICAgICBncmFtbWFyRm9yVGV4dEVkaXRvcnNMaXN0ZW5lciA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ic2VydmVHcmFtbWFyRm9yVGV4dEVkaXRvcnM7XG4iXX0=